// ******************************************   200. Number of Islands   ****************************************** //
// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.
// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
// https://leetcode.com/problems/number-of-islands/
//
/** @param {character[][]} grid **/ /** @return {number} **/
//
// BFS
{
  const numIslands = (grid) => {
    if (!grid.length) return 0;
    const ROWS = grid.length, COLS = grid[0].length, directions = [[1, 0],[-1, 0],[0, 1],[0, -1]], visit = new Set();
    let islands = 0;

    const bfs = (r, c) => {
      const q = [[r, c]];
      visit.add(`${r}${c}`);

      while (q.length) {
        const [row, col] = q.pop();

        for (const [dr, dc] of directions) {
          const r = row + dr, c = col + dc;
          if (r >= 0 && r < ROWS && c >= 0 && c < COLS && grid[r][c] == '1' && !visit.has(`${r}${c}`)) {
            q.splice(0, 0, [r, c]);
            visit.add(`${r}${c}`);
          }
        }
      }
    };

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid[r][c] == '1' && !visit.has(`${r}${c}`)) {
          bfs(r, c);
          islands++;
        }
      }
    }

    return islands;
  };
}
// 
// Runtime:        143 ms, faster than 42.88%   |    110 ms, faster than 76.02%
// Memory Usage:  49.6 MB, less than   38.77%   |   49.4 MB, less than   39.74%
const numIslands = (grid) => {
  if (!grid.length) return 0;
  const ROWS = grid.length, COLS = grid[0].length, queue = [], directions = [[-1, 0],[0, 1],[1, 0],[0, -1]];
  let islands = 0;

  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      if (grid[row][col] === '1') {
        islands++;
        grid[row][col] = '0';
        queue.push([row, col]);
        
        while (queue.length > 0) {
          const [r, c] = queue.shift();

          for (const [dr, dc] of directions) {
            const nr = r + dr, nc = c + dc;
            if ((0 <= nr && nr < ROWS) && (0 <= nc && nc < COLS) && grid[nr][nc] === '1') {
              grid[nr][nc] = '0';
              queue.push([nr, nc]);
            }
          }
        }
      }
    }
  }
  return islands;
};
// **************************************************************************************************************** //

console.log(
  numIslands([
    ['1', '1', '1', '1', '0'],
    ['1', '1', '0', '1', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '0', '0', '0'],
  ])
);
console.log(
  numIslands([
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1'],
  ])
);
console.log(
  numIslands([
    ['1', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '0', '1', '0'],
    ['0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '1', '0', '1', '0'],
    ['0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '1'],
    ['0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['1', '0', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0', '1'],
    ['0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1'],
    ['0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0'],
    ['0', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1'],
    ['0', '0', '1', '0', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0', '0', '1', '0'],
    ['1', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '1', '0', '1', '0'],
    ['0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0', '1', '1', '0', '0'],
    ['1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1'],
    ['0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '1', '0', '0', '0'],
    ['0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'],
    ['1', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1'],
    ['1', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'],
    ['0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '0', '0'],
    ['0', '1', '0', '0', '0', '0', '1', '1', '0', '0', '1', '0', '1', '0', '0', '1', '0', '0', '1', '1'],
    ['0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', '0'],
  ])
);

// Example 1:
// Input: grid = [
//   ["1","1","1","1","0"],
//   ["1","1","0","1","0"],
//   ["1","1","0","0","0"],
//   ["0","0","0","0","0"]
// ]
// Output: 1

// Example 2:
// Input: grid = [
//   ["1","1","0","0","0"],
//   ["1","1","0","0","0"],
//   ["0","0","1","0","0"],
//   ["0","0","0","1","1"]
// ]
// Output: 3

// Constraints:
// m == grid.length
// n == grid[i].length
// 1 <= m, n <= 300
// grid[i][j] is '0' or '1'.